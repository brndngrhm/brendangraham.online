---
title: "Wimbledon analysis part 1: get the data"
weight: 1
author: Brendan Graham
date: '2022-02-02'
slug: tennis-part1
categories: 
  - tennis
  - R
tags:
  - tennis
  - R
subtitle: 
summary: 'This post is the first in a series on analyzing Wimbledon tournament data.'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
draft: false
editor_options: 
  chunk_output_type: console
---

```{r include = FALSE}
knitr::opts_chunk$set(echo = T, fig.height = 7, fig.width = 9, message = FALSE, warning = FALSE)
library(dplyr)
library(feather)
library(readr)
library(purrr)
library(glue)
library(janitor)
library(here)
library(stringr)
```

## Introduction

This is the first in a series of posts analyzing data from recent Wimbledon tournaments. In this post I will talk through how I retrieve and format the data. the point by point and match data come from this [amazing repo](https://github.com/JeffSackmann/tennis_slam_pointbypoint/) that has point by point data for Wimbledon and many more tournaments.

## Get the data

I want to use several years worth of data. Rather than load the match data and the point by point data manually, the `get_url()` and `get_data()` functions below streamline the process.

```{r}
# no tournament in 2020
years <-
  c(seq(2015, 2019, 1), 2021)

get_url <- 
  function(year, type){
    
    if(!type %in% c('points', 'matches')) stop("Type must be one of 'points' or 'maches'")
    
    glue('https://raw.githubusercontent.com/JeffSackmann/tennis_slam_pointbypoint/master/{year}-wimbledon-{type}.csv')
    
  }

get_data <- 
  function(url){
    
    #points datasets needs an extra step in order to use map_dfr
    data <- 
      if (str_detect(url, "points")){
        read_csv({{url}}) %>%
          as_tibble() %>%
          # this step needed for map_dfr(); in some datasets point number is numeric, others its a character
          mutate(PointNumber = as.numeric(PointNumber)) %>%
          clean_names()
        
      } else {
        
        readr::read_csv({{url}}) %>%
          as_tibble() %>%
          janitor::clean_names()
      }
    
    data
    
  }

```

Here I map my 2 functions over the years list and retrieve the points and matches data from 2015-2021
```{r}
points <-
  map(years, ~get_url(.x, type = 'points')) %>%
  map_dfr(., ~get_data(.x)) 

points

```

```{r}

matches <-
  map(years, ~get_url(.x, type = 'matches')) %>%
  map_dfr(., ~get_data(.x)) 

matches
```

At this point I would normally save the data to a `data/raw` directory to preserve its initial state. Then I would create a separate script to read in the raw data to clean and format it. I skip that step here but below is the the code I would use to do that.

```{r eval = FALSE}

write_feather(points, here("wimbledon", "data", "raw", "points.feather"))
write_feather(matches, here("wimbledon", "data", "raw" "matches.feather"))

```

## Clean the data

The next step is to clean and prep the data for analysis.

### Match data

The matches dataset has a ton of missing data, so we can ignore most columns. Also, we cab deconstruct `match_num` to extract meaningful match metadata. For example, the first number seems to indicate a mens match (1) vs a womens match (2), the 2nd number is the round in which the match took place and the last 2 numbers are the match number. The `format_matches` function applies these steps  

```{r}
matches
```

```{r}
format_matches <- 
  function(){
    matches %>%
      select(match_id:player2) %>%
      mutate(category = ifelse(str_sub(match_num, 1, 1) == 1, "men", "women"),
             round = str_sub(match_num, 2, 2),
             match_no = as.numeric(str_sub(match_num, 3, 4)))
  }

format_matches()

```

It'll probably be useful to have a column for match winner. To get the winner for each match we can turn to the points data and use `p1games_won` and `p2games_won` to determine the match winner.

```{r}

get_match_winner <- 
  function(){
    
    points %>%
      filter(set_winner > 0) %>%
      select(match_id, p1games_won, p2games_won) %>%
      group_by(match_id) %>%
      summarise(tot_p1games_won = sum(p1games_won),
                tot_p2games_won = sum(p2games_won)) %>%
      mutate(match_winner = ifelse(tot_p1games_won > tot_p2games_won, "player1", "player2")) %>%
      select(match_id, match_winner)
  }

get_match_winner()

```

Finally we can apply and join the the 2 functions to get our cleaned matches dataset. (As above, for the purposes of this post we'll skip the step of saving the cleaned data, but the code to do so is included below).

```{r}

matches <- 
  format_matches() %>%
  inner_join(., get_match_winner()) %>%
  mutate(match_winner = ifelse(match_winner == "player1", player1, player2))

matches

# write_feather(matches, here("wimbledon", "data", "formatted", "matches.feather"))

```

### Points data

```{r}
points
```

The first part of `format_points()` creates some time columns: match minutes, set minutes and game minutes. then I add some sequence numbers that assigns a row number for each game, set and match. This comes in handy when trying to determine how many points happen in each game, set or match, and also helps to partition sets and games within a match, `game_seq` will reset after every game, `set_seq` rests after each set and `match_seq` is a sequence of row number from 1 to the end of the match.

```{r}
format_points <- 
  function(){

    time <- 
      points %>%
      filter(point_number > 0) %>%
      select(match_id, set_no, elapsed_time) %>%
      group_by(match_id, set_no) %>%
      filter(elapsed_time == max(elapsed_time)) %>%
      ungroup() %>%
      group_by(match_id) %>%
      mutate(
        set_length_mins = case_when(
          set_no == 1 ~ as.numeric(elapsed_time)/60,
          TRUE ~ (as.numeric(elapsed_time) - lag(as.numeric(elapsed_time)))/60),
        game_length_mins = sum(set_length_mins)
      )
    
    points_formatted <- 
      points %>%
      filter(point_number > 0) %>%
      group_by(match_id) %>%
      mutate(match_seq = dplyr::row_number()) %>%
      ungroup() %>%
      group_by(match_id, set_no) %>%
      mutate(set_seq = dplyr::row_number()) %>%
      ungroup() %>%
      group_by(match_id, set_no, game_no) %>%
      mutate(game_seq = dplyr::row_number()) %>%
      ungroup() %>% 
      inner_join(., time %>% select(-elapsed_time), by = c("match_id", "set_no")) %>%
      select(match_id, set_no, match_seq:game_length_mins, everything()) %>%
      mutate(p1score = as.numeric(p1score),
             p2score = as.numeric(p2score))
    
    points_formatted
    
  }

points

# write_feather(points, here("wimbledon", "data", "formatted", "points.feather"))

```


